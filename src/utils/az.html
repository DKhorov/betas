<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Pixel Art Editor Pro</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-color: #2d2d2d;
            --text-color: #e0e0e0;
            --accent-color: #007acc;
            --border-color: #444;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* Toolbar */
        .toolbar {
            background-color: var(--panel-color);
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .group {
            display: flex;
            gap: 5px;
            padding-right: 10px;
            border-right: 1px solid var(--border-color);
            align-items: center;
        }
        .group:last-child { border-right: none; }

        button, input[type="number"], select {
            background-color: #3c3c3c;
            border: 1px solid var(--border-color);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover { background-color: #505050; }
        button.active { background-color: var(--accent-color); border-color: #005f9e; }

        input[type="color"] {
            border: none;
            width: 40px;
            height: 30px;
            cursor: pointer;
            background: none;
        }

        label { font-size: 12px; margin-right: 5px; }

        /* Workspace */
        #workspace {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-image: 
                linear-gradient(45deg, #252525 25%, transparent 25%), 
                linear-gradient(-45deg, #252525 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #252525 75%), 
                linear-gradient(-45deg, transparent 75%, #252525 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            cursor: crosshair;
        }

        canvas {
            image-rendering: pixelated; /* –í–∞–∂–Ω–æ –¥–ª—è –ø–∏–∫—Å–µ–ª—å-–∞—Ä—Ç–∞ */
            display: block;
        }

        .status-bar {
            background-color: var(--panel-color);
            padding: 5px 10px;
            font-size: 12px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body>

<div class="toolbar">
    <div class="group">
        <label>–®–∏—Ä–∏–Ω–∞:</label>
        <input type="number" id="gridW" value="32" min="1" max="1000" style="width: 50px;">
        <label>–í—ã—Å–æ—Ç–∞:</label>
        <input type="number" id="gridH" value="32" min="1" max="1000" style="width: 50px;">
        <button onclick="resizeGrid()">–°–æ–∑–¥–∞—Ç—å</button>
    </div>

    <div class="group">
        <input type="color" id="colorPicker" value="#000000">
        <button id="btnPencil" class="active" onclick="setTool('pencil')">‚úèÔ∏è</button>
        <button id="btnEraser" onclick="setTool('eraser')">üßπ –õ–∞—Å—Ç–∏–∫</button>
        <button id="btnFill" onclick="setTool('fill')">ü™£ –ó–∞–ª–∏–≤–∫–∞</button>
        <button id="btnPicker" onclick="setTool('picker')">üíâ –ü–∏–ø–µ—Ç–∫–∞</button>
    </div>

    <div class="group">
        <button onclick="resetView()">üëÅÔ∏è –°–±—Ä–æ—Å –≤–∏–¥–∞</button>
        <label><input type="checkbox" id="showGrid" checked onchange="requestRender()"> –°–µ—Ç–∫–∞</label>
    </div>

    <div class="group">
        <select id="exportFormat">
            <option value="png">PNG</option>
            <option value="jpeg">JPEG</option>
            <option value="webp">WEBP</option>
            <option value="svg">SVG</option>
            <option value="html">HTML</option>
            <option value="obj">OBJ (3D)</option>
        </select>
        <button onclick="exportFile()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
    </div>
</div>

<div id="workspace">
    <canvas id="mainCanvas"></canvas>
</div>

<div class="status-bar">
    <span id="coords">X: 0, Y: 0</span>
    <span>–ö–æ–ª–µ—Å–æ: –ó—É–º | –°—Ä–µ–¥–Ω—è—è –∫–Ω–æ–ø–∫–∞/–ü—Ä–æ–±–µ–ª: –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ</span>
</div>

<script>
    // --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ---
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const workspace = document.getElementById('workspace');
    
    // –°–æ—Å—Ç–æ—è–Ω–∏–µ
    let gridWidth = 32;
    let gridHeight = 32;
    let pixels = []; // –î–≤—É–º–µ—Ä–Ω—ã–π –º–∞—Å—Å–∏–≤ [y][x] —Ö—Ä–∞–Ω–∏—Ç —Å—Ç—Ä–æ–∫–∏ —Ü–≤–µ—Ç–æ–≤ (hex) –∏–ª–∏ null
    
    let scale = 20; // –£—Ä–æ–≤–µ–Ω—å –∑—É–º–∞
    let panX = 0;
    let panY = 0;
    
    let isDrawing = false;
    let isPanning = false;
    let lastMouseX, lastMouseY;
    
    let currentTool = 'pencil';
    let primaryColor = '#000000';

    // --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ---
    function initPixels(w, h) {
        let newPixels = [];
        for (let y = 0; y < h; y++) {
            let row = [];
            for (let x = 0; x < w; x++) {
                row.push(null);
            }
            newPixels.push(row);
        }
        return newPixels;
    }

    function resizeGrid() {
        const w = parseInt(document.getElementById('gridW').value);
        const h = parseInt(document.getElementById('gridH').value);
        if (w > 0 && h > 0) {
            if(confirm("–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π —Å–µ—Ç–∫–∏ —Å–æ—Ç—Ä–µ—Ç —Ç–µ–∫—É—â–∏–π —Ä–∏—Å—É–Ω–æ–∫. –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å?")) {
                gridWidth = w;
                gridHeight = h;
                pixels = initPixels(w, h);
                resetView();
                requestRender();
            }
        }
    }

    function resetView() {
        // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º —Å–µ—Ç–∫—É
        scale = Math.min(workspace.clientWidth / gridWidth, workspace.clientHeight / gridHeight) * 0.8;
        if (scale < 1) scale = 1;
        panX = (workspace.clientWidth - gridWidth * scale) / 2;
        panY = (workspace.clientHeight - gridHeight * scale) / 2;
        requestRender();
    }

    // –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫
    pixels = initPixels(gridWidth, gridHeight);
    
    // –ü–æ–¥—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä canvas –ø–æ–¥ –æ–∫–Ω–æ
    function resizeCanvas() {
        canvas.width = workspace.clientWidth;
        canvas.height = workspace.clientHeight;
        requestRender();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    resetView();

    // --- –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ ---
    function requestRender() {
        window.requestAnimationFrame(render);
    }

    function render() {
        // –û—á–∏—Å—Ç–∫–∞
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.save();
        ctx.translate(panX, panY);
        ctx.scale(scale, scale);

        // –†–∏—Å—É–µ–º —Ñ–æ–Ω —Å–µ—Ç–∫–∏ (–±–µ–ª—ã–π)
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, gridWidth, gridHeight);

        // –†–∏—Å—É–µ–º –ø–∏–∫—Å–µ–ª–∏
        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                if (pixels[y][x]) {
                    ctx.fillStyle = pixels[y][x];
                    // –†–∏—Å—É–µ–º —á—É—Ç—å –±–æ–ª—å—à–µ 1, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ª–∏–Ω–∏–π —Å—Ç—ã–∫–æ–≤ –ø—Ä–∏ –∑—É–º–µ
                    ctx.fillRect(x, y, 1.05, 1.05); 
                }
            }
        }

        // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É
        if (document.getElementById('showGrid').checked && scale > 5) {
            ctx.lineWidth = 0.05; // –¢–æ–Ω–∫–∞—è –ª–∏–Ω–∏—è –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∑—É–º–∞
            ctx.strokeStyle = '#ccc';
            
            ctx.beginPath();
            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ
            for (let x = 0; x <= gridWidth; x++) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, gridHeight);
            }
            // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ
            for (let y = 0; y <= gridHeight; y++) {
                ctx.moveTo(0, y);
                ctx.lineTo(gridWidth, y);
            }
            ctx.stroke();
        }

        // –ì—Ä–∞–Ω–∏—Ü–∞ —Ö–æ–ª—Å—Ç–∞
        ctx.lineWidth = 2 / scale;
        ctx.strokeStyle = '#444';
        ctx.strokeRect(0, 0, gridWidth, gridHeight);

        ctx.restore();
    }

    // --- –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã ---
    function setTool(tool) {
        currentTool = tool;
        document.querySelectorAll('.toolbar button').forEach(b => b.classList.remove('active'));
        if(tool === 'pencil') document.getElementById('btnPencil').classList.add('active');
        if(tool === 'eraser') document.getElementById('btnEraser').classList.add('active');
        if(tool === 'fill') document.getElementById('btnFill').classList.add('active');
        if(tool === 'picker') document.getElementById('btnPicker').classList.add('active');
    }

    document.getElementById('colorPicker').addEventListener('change', (e) => {
        primaryColor = e.target.value;
    });

    // --- –õ–æ–≥–∏–∫–∞ –†–∏—Å–æ–≤–∞–Ω–∏—è ---
    function getGridCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // –û–±—Ä–∞—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        const gridX = Math.floor((mouseX - panX) / scale);
        const gridY = Math.floor((mouseY - panY) / scale);
        
        return { x: gridX, y: gridY };
    }

    function plot(x, y) {
        if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) return;

        if (currentTool === 'pencil') {
            pixels[y][x] = primaryColor;
        } else if (currentTool === 'eraser') {
            pixels[y][x] = null;
        } else if (currentTool === 'picker') {
            const c = pixels[y][x];
            if (c) {
                primaryColor = c;
                document.getElementById('colorPicker').value = c;
                setTool('pencil');
            }
        }
    }

    function floodFill(startX, startY, newColor) {
        if (startX < 0 || startX >= gridWidth || startY < 0 || startY >= gridHeight) return;
        
        const targetColor = pixels[startY][startX];
        if (targetColor === newColor) return; // –£–∂–µ —ç—Ç–æ—Ç —Ü–≤–µ—Ç

        const stack = [[startX, startY]];
        
        while (stack.length) {
            const [x, y] = stack.pop();
            
            if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) continue;
            if (pixels[y][x] !== targetColor) continue;
            
            pixels[y][x] = newColor;
            
            stack.push([x + 1, y]);
            stack.push([x - 1, y]);
            stack.push([x, y + 1]);
            stack.push([x, y - 1]);
        }
    }

    // --- –°–æ–±—ã—Ç–∏—è –º—ã—à–∏ ---
    canvas.addEventListener('mousedown', (e) => {
        if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
            // –°—Ä–µ–¥–Ω—è—è –∫–Ω–æ–ø–∫–∞ –∏–ª–∏ Shift+–õ–ö–ú = –ü–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ
            isPanning = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            e.preventDefault();
            return;
        }
        
        if (e.button === 0) {
            const { x, y } = getGridCoords(e);
            
            if (currentTool === 'fill') {
                if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                    floodFill(x, y, primaryColor);
                    requestRender();
                }
            } else {
                isDrawing = true;
                plot(x, y);
                requestRender();
            }
        }
    });

    window.addEventListener('mousemove', (e) => {
        const { x, y } = getGridCoords(e);
        document.getElementById('coords').innerText = `X: ${x}, Y: ${y}`;

        if (isPanning) {
            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;
            panX += dx;
            panY += dy;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            requestRender();
        } else if (isDrawing) {
            plot(x, y);
            requestRender();
        }
    });

    window.addEventListener('mouseup', () => {
        isDrawing = false;
        isPanning = false;
    });

    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        
        const zoomSpeed = 0.1;
        const zoomFactor = e.deltaY < 0 ? (1 + zoomSpeed) : (1 - zoomSpeed);
        
        // –ó—É–º –≤ —Ç–æ—á–∫—É –∫—É—Ä—Å–æ—Ä–∞
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const newScale = scale * zoomFactor;
        
        if (newScale > 0.1 && newScale < 100) {
            panX = mouseX - (mouseX - panX) * zoomFactor;
            panY = mouseY - (mouseY - panY) * zoomFactor;
            scale = newScale;
            requestRender();
        }
    }, { passive: false });

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ–±–µ–ª–∞ –¥–ª—è –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏—è
    let spacePressed = false;
    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            spacePressed = true;
            canvas.style.cursor = 'grab';
        }
    });
    window.addEventListener('keyup', (e) => {
        if (e.code === 'Space') {
            spacePressed = false;
            canvas.style.cursor = 'crosshair';
            isPanning = false;
        }
    });


    // --- –≠–∫—Å–ø–æ—Ä—Ç ---
    function exportFile() {
        const format = document.getElementById('exportFormat').value;
        const fileName = `pixelart_${Date.now()}`;

        if (format === 'html') {
            exportHTML(fileName);
        } else if (format === 'svg') {
            exportSVG(fileName);
        } else if (format === 'obj') {
            exportOBJ(fileName);
        } else {
            // PNG, JPEG, WEBP
            exportImage(format, fileName);
        }
    }

    function exportImage(format, fileName) {
        // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π canvas —Ç–æ—á–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = gridWidth;
        tempCanvas.height = gridHeight;
        const tCtx = tempCanvas.getContext('2d');
        
        // –ó–∞–ø–æ–ª–Ω—è–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –±–µ–ª—ã–º, –µ—Å–ª–∏ JPEG
        if (format === 'jpeg') {
            tCtx.fillStyle = '#ffffff';
            tCtx.fillRect(0,0, gridWidth, gridHeight);
        }

        pixels.forEach((row, y) => {
            row.forEach((color, x) => {
                if (color) {
                    tCtx.fillStyle = color;
                    tCtx.fillRect(x, y, 1, 1);
                }
            });
        });

        const link = document.createElement('a');
        link.download = `${fileName}.${format}`;
        link.href = tempCanvas.toDataURL(`image/${format}`);
        link.click();
    }

    function exportSVG(fileName) {
        let svgContent = `<svg width="${gridWidth * 10}" height="${gridHeight * 10}" viewBox="0 0 ${gridWidth} ${gridHeight}" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges">`;
        // –§–æ–Ω (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        // svgContent += `<rect width="${gridWidth}" height="${gridHeight}" fill="white"/>`;
        
        pixels.forEach((row, y) => {
            row.forEach((color, x) => {
                if (color) {
                    svgContent += `<rect x="${x}" y="${y}" width="1" height="1" fill="${color}" />`;
                }
            });
        });
        svgContent += '</svg>';
        
        downloadString(svgContent, `${fileName}.svg`, 'image/svg+xml');
    }

    function exportHTML(fileName) {
        let html = `<!DOCTYPE html><html><head><style>table{border-collapse:collapse;} td{width:10px;height:10px;padding:0;}</style></head><body><table>`;
        pixels.forEach(row => {
            html += `<tr>`;
            row.forEach(color => {
                html += `<td style="background-color:${color || 'transparent'}"></td>`;
            });
            html += `</tr>`;
        });
        html += `</table></body></html>`;
        downloadString(html, `${fileName}.html`, 'text/html');
    }

    function exportOBJ(fileName) {
        // –ü—Ä–æ—Å—Ç–æ–π —ç–∫—Å–ø–æ—Ä—Ç –≤ 3D (–≤–æ–∫—Å–µ–ª–∏)
        // –°–æ–∑–¥–∞–µ—Ç –∫—É–± –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–∏–∫—Å–µ–ª—è
        let obj = "# Pixel Art 3D Export\n";
        let vertCount = 0;
        
        pixels.forEach((row, y) => {
            row.forEach((color, x) => {
                if (color) {
                    // Y –≤ 3D –æ–±—ã—á–Ω–æ –≤–≤–µ—Ä—Ö, —Ç–∞–∫ —á—Ç–æ –∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∏–ª–∏ –∫–ª–∞–¥–µ–º –Ω–∞ –ø–ª–æ—Å–∫–æ—Å—Ç—å
                    // –°–¥–µ–ª–∞–µ–º "—Å—Ç–µ–Ω—É" (XY –ø–ª–æ—Å–∫–æ—Å—Ç—å)
                    
                    // –í–µ—Ä—à–∏–Ω—ã –∫—É–±–∞
                    // x, y inverted, 0
                    const yInv = -y;
                    
                    obj += `v ${x} ${yInv} 0\n`; // 1
                    obj += `v ${x+1} ${yInv} 0\n`; // 2
                    obj += `v ${x+1} ${yInv-1} 0\n`; // 3
                    obj += `v ${x} ${yInv-1} 0\n`; // 4
                    
                    obj += `v ${x} ${yInv} 1\n`; // 5
                    obj += `v ${x+1} ${yInv} 1\n`; // 6
                    obj += `v ${x+1} ${yInv-1} 1\n`; // 7
                    obj += `v ${x} ${yInv-1} 1\n`; // 8

                    // –õ–∏—Ü–∞ (Faces)
                    obj += `f ${vertCount+1} ${vertCount+2} ${vertCount+3} ${vertCount+4}\n`; // Front
                    obj += `f ${vertCount+8} ${vertCount+7} ${vertCount+6} ${vertCount+5}\n`; // Back
                    obj += `f ${vertCount+4} ${vertCount+3} ${vertCount+7} ${vertCount+8}\n`; // Top
                    obj += `f ${vertCount+1} ${vertCount+5} ${vertCount+6} ${vertCount+2}\n`; // Bottom
                    obj += `f ${vertCount+1} ${vertCount+4} ${vertCount+8} ${vertCount+5}\n`; // Left
                    obj += `f ${vertCount+2} ${vertCount+6} ${vertCount+7} ${vertCount+3}\n`; // Right

                    vertCount += 8;
                }
            });
        });
        
        downloadString(obj, `${fileName}.obj`, 'text/plain');
    }

    function downloadString(text, name, type) {
        const file = new Blob([text], {type: type});
        const a = document.createElement("a");
        a.href = URL.createObjectURL(file);
        a.download = name;
        a.click();
    }

</script>

</body>
</html>